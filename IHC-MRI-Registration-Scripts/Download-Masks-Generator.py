#!/usr/bin/env python3
"""
QuPath Annotation Mask Batch Downloader Generator

This script reads a list of annotation names and generates a groovy script
that downloads all specified annotation masks from QuPath as binary TIFF files.
Creates full-sized masks matching WSI dimensions with proper spatial relationships.

Usage:
    python generate_qupath_script.py [annotation_list_file] [output_groovy_file]
"""

import sys
import os
from pathlib import Path

def read_annotation_list(file_path):
    """Read annotation names from a text file, one name per line."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            # Read lines, strip whitespace, and filter out empty lines
            annotations = [line.strip() for line in f.readlines() if line.strip()]
        return annotations
    except FileNotFoundError:
        print(f"Error: Could not find annotation list file: {file_path}")
        return None
    except Exception as e:
        print(f"Error reading annotation list file: {e}")
        return None

def generate_groovy_script(annotations, output_dir_path, downsample_factor=10.0):
    """Generate the groovy script content for QuPath."""
    
    # Convert Windows paths to use forward slashes for groovy
    output_dir_path = output_dir_path.replace('\\', '/')
    
    groovy_template = f'''// Auto-generated groovy script for QuPath annotation mask download
// Generated by QuPath Annotation Mask Generator
// Downloads multiple annotation masks as binary TIFF files
// Creates full-sized masks matching WSI dimensions

import java.awt.Color
import java.awt.image.BufferedImage
import javax.imageio.ImageIO
import java.awt.RenderingHints
import java.awt.Graphics2D

// Configuration - using absolute path to ensure correct location
def outputPath = "{output_dir_path}"
def downsample = {downsample_factor}  // Fixed downsample factor

// Print the intended output path for debugging
println("Intended output directory: ${{outputPath}}")

// Create output directory if it doesn't exist using absolute path
def outputDir = new File(outputPath)
if (!outputDir.exists()) {{
    boolean created = outputDir.mkdirs()
    if (created) {{
        println("Created output directory: ${{outputPath}}")
    }} else {{
        println("Failed to create output directory: ${{outputPath}}")
        return
    }}
}} else {{
    println("Output directory already exists: ${{outputPath}}")
}}

// Get current image data
def imageData = getCurrentImageData()
if (imageData == null) {{
    println("No image open!")
    return
}}

def server = imageData.getServer()
def hierarchy = imageData.getHierarchy()

// Get full WSI dimensions
def width = server.getWidth()
def height = server.getHeight()

// Calculate downsampled dimensions
def newWidth = (int)(width / downsample)
def newHeight = (int)(height / downsample)

println("Original WSI dimensions: ${{width}}x${{height}}")
println("Downsampled dimensions: ${{newWidth}}x${{newHeight}}")
println("Using downsample factor: ${{downsample}}")
println("Output directory: ${{outputPath}}")

// List of annotations to download
def annotationNames = {annotations}

println("Starting batch download of " + annotationNames.size() + " annotation masks...")

// Process each annotation type
annotationNames.each {{ annotationName ->
    println("Processing annotation: " + annotationName)
    
    // Find annotations with the specified name
    def selectedAnnotations = hierarchy.getAnnotationObjects().findAll {{ 
        it.getPathClass()?.getName() == annotationName 
    }}
    
    if (selectedAnnotations.isEmpty()) {{
        println("WARNING: No annotations with classification '${{annotationName}}' were found!")
        return
    }}
    
    println("Number of ${{annotationName}} annotations found: ${{selectedAnnotations.size()}}")
    
    try {{
        // Create binary mask with full downsampled dimensions
        def mask = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_BYTE_GRAY)
        def g2d = mask.createGraphics()
        
        // Set rendering hints for better quality
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)
        g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY)
        
        // Set up transform for downsampling
        g2d.scale(1.0/downsample, 1.0/downsample)
        g2d.setColor(Color.WHITE)
        
        // Draw all annotations of this type as white on black background
        for (annotation in selectedAnnotations) {{
            def roi = annotation.getROI()
            if (roi != null) {{
                def shape = roi.getShape()
                g2d.fill(shape)
                println("Processing ${{annotationName}} annotation: ${{annotation.getName()}}")
            }} else {{
                println("Warning: No ROI found for annotation ${{annotation.getName()}}")
            }}
        }}
        g2d.dispose()
        
        // Generate filename and full file path
        def filename = annotationName + "_mask.tif"
        def outputFile = new File(outputPath, filename)
        def absoluteOutputPath = outputFile.getAbsolutePath()
        
        println("Saving to absolute path: ${{absoluteOutputPath}}")
        
        // Save the binary mask
        ImageIO.write(mask, 'TIFF', outputFile)
        println("Saved: ${{filename}} (Size: ${{newWidth}}x${{newHeight}})")
        println("File saved at: ${{absoluteOutputPath}}")
        
    }} catch (Exception e) {{
        println("Error processing annotation '${{annotationName}}': " + e.getMessage())
        e.printStackTrace()
    }}
}}

println("Batch download completed!")
println("Files saved to: ${{outputPath}}")
println("Verify files are in: ${{new File(outputPath).getAbsolutePath()}}")
'''
    
    return groovy_template

def create_sample_annotation_list(file_path):
    """Create a sample annotation list file."""
    sample_annotations = [
        "WM",
        "WM_Lesion", 
        "GM",
        "Surrounding_WM"
    ]
    
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            for annotation in sample_annotations:
                f.write(annotation + "\n")
        print(f"Created sample annotation list: {file_path}")
        return True
    except Exception as e:
        print(f"Error creating sample file: {e}")
        return False

def main():
    # Default file paths
    default_annotation_file = "annotation_list.txt"
    default_groovy_file = "download_annotation_masks.groovy"
    
    # Parse command line arguments
    if len(sys.argv) > 1:
        annotation_file = sys.argv[1]
    else:
        annotation_file = default_annotation_file
        
    if len(sys.argv) > 2:
        groovy_file = sys.argv[2]
    else:
        groovy_file = default_groovy_file
    
    # Create sample annotation list if it doesn't exist
    if not os.path.exists(annotation_file):
        print(f"Annotation list file '{annotation_file}' not found.")
        response = input(f"Create sample annotation list file '{annotation_file}'? (y/n): ")
        if response.lower() in ['y', 'yes']:
            if not create_sample_annotation_list(annotation_file):
                return 1
        else:
            print("Please create an annotation list file with one annotation name per line.")
            return 1
    
    # Read annotation names
    annotations = read_annotation_list(annotation_file)
    if annotations is None:
        return 1
    
    if not annotations:
        print("No annotation names found in the file.")
        return 1
    
    print(f"Found {len(annotations)} annotation names:")
    for i, name in enumerate(annotations, 1):
        print(f"  {i}. {name}")
    
    # Set fixed downsample factor
    downsample = 10.0
    
    # Create output directory path in the same location as the Python script
    script_dir = os.path.dirname(os.path.abspath(__file__)) if __file__ else os.getcwd()
    output_dir_path = os.path.join(script_dir, "Annotation_masks")
    
    # Debug: Print the paths being used
    print(f"\nScript directory: {script_dir}")
    print(f"Output directory will be: {output_dir_path}")
    
    # Generate groovy script
    groovy_content = generate_groovy_script(annotations, output_dir_path, downsample)
    
    # Write groovy script to file
    try:
        with open(groovy_file, 'w', encoding='utf-8') as f:
            f.write(groovy_content)
        print(f"\nGroovy script generated successfully: {groovy_file}")
        print(f"Using fixed downsample factor: {downsample}")
        print(f"Output directory: {output_dir_path}")
        print(f"\nTo use:")
        print(f"1. Open QuPath")
        print(f"2. Open your project/image")
        print(f"3. Run the generated groovy script: {groovy_file}")
        print(f"4. Annotation masks will be saved to: {output_dir_path}")
        print(f"\nNote: Masks will have full WSI dimensions (downsampled by factor {downsample})")
        print(f"This should produce ~44.8 MB files matching your original export size.")
        
    except Exception as e:
        print(f"Error writing groovy script: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
